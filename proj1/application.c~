#include "application.h"
#include "link.h"
#include <stdint.h>

#define CTRL_PKG_START	1
#define CTRL_PKG_DATA	0
#define CTRL_PKG_END	2

#define PARAM_FILE_SIZE		0
#define PARAM_FILE_NAME		1

#define CTRL_C 		0
#define CTRL_T1		1
#define CTRL_L1		2
#define DATA_C		0
#define DATA_N		1
#define DATA_L2		0
#define DATA_L1		3
#define DATA_P		4

#define PROGRESS_LENGTH		40
#define APPLICATION_DEBUG 	1
#define LOG(msg)			if (APPLICATION_DEBUG) puts(msg);

ApplicationLayer* al = NULL;

void logProgress(double current, double total) {

	const double percentage = 100.0 * current / total;
	const int pos = (int)(percentage * PROGRESS_LENGTH / 100.0);
	int i;
	
	printf("Completed: %6.2f%% [", percentage);

	for (i = 0; i < PROGRESS_LENGTH; i++) {
		i <= pos ? printf("=") : printf(" ");
	}

	puts("]\n");
}

static const uint32_t crc32_tab[] = {

	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
	0xe963a535, 0x9e6495a3,	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
	0xf3b97148, 0x84be41de,	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,	0x14015c4f, 0x63066cd9,
	0xfa0f3d63, 0x8d080df5,	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,	0x35b5a8fa, 0x42b2986c,
	0xdbbbc9d6, 0xacbcf940,	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,	0x76dc4190, 0x01db7106,
	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

static uint32_t crc32(uint32_t crc, const void* buf, size_t size) {

	const uint8_t *p = buf;

	crc = crc ^ ~0U;

	while (size--) {
		crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
	}

	return crc ^ ~0U;
}

static unsigned calculate_size(FILE* file) {

	unsigned currentPosition = ftell(file);
	unsigned currentSize;

	if (fseek(file, 0, SEEK_END) < 0) {
		return -1;
	}

	currentSize = ftell(file);
	fseek(file, 0, currentPosition);

	return currentSize;
}

/**
 * DATA PACKAGES
 */

static int send_data(int fd, int N, const unsigned char* buffer, int length) {

	int rv = 0;
	unsigned packageSize = 4 + length;
	unsigned char* DP = (unsigned char*) malloc(packageSize * sizeof(unsigned char));

	DP[DATA_C] = CTRL_PKG_DATA;
	DP[DATA_N] = N;
	DP[DATA_L2] = length / 256;
	DP[DATA_L1] = length % 256;
	memcpy(&DP[DATA_P], buffer, length);

	if (llwrite(fd, DP, packageSize) < 0) {
		puts("[ERROR] DATA package not sent: serial port write failed...");
		rv = -1;
	}

	free(DP);

	return rv;
}

static int receive_data(int fd, int* N, unsigned char* buffer, int* length) {

	unsigned char* DP = (unsigned char*) malloc(MAX_SIZE * sizeof(unsigned char));
	unsigned packageSize = llread(fd, DP);
	int rv = 0;

	if (packageSize < 0) {
		puts("[ERROR] DATA package not received: serial port read failed...");
		rv = -1;
	}
	else if (DP[DATA_C] != CTRL_PKG_DATA) {
		puts("[ERROR] received wrong DATA package: control field is not CTRL_PKG_DATA...");
		rv = -1;
	}
	else {
		printf("saved N, value=%d\n", *N);
		*N = DP[DATA_N];
		*length = 256 * DP[DATA_L2] + DP[DATA_L1];
		memcpy(buffer, &DP[DATA_P], *length);
	}

	free(DP);

	return rv;
}

/**
 * CONTROL PACKAGES
 */

static int send_control(int fd, unsigned char C, const char* fileSize, const char* fileName) {

	int rv = 0;

	if (C == CTRL_PKG_START) {
		LOG("[INFORMATION] sending START control package to RECEIVER...");
	}
	else if (C == CTRL_PKG_END) {
		LOG("[INFORMATION] sending END control package to RECEIVER...");
	}
	else {
		LOG("[ERROR] sending UNKNOWN control package to RECEIVER...");
		return -1;
	}

	const unsigned sizeLength = strlen(fileSize);
	const unsigned nameLength = strlen(fileName);
	
	int i = 3;
	unsigned packageSize = 5 + sizeLength + nameLength;
	unsigned char* CP = (unsigned char*) malloc(packageSize * sizeof(unsigned char));

	CP[CTRL_C] = C;
	CP[CTRL_T1] = PARAM_FILE_SIZE;
	CP[CTRL_L1] = sizeLength;
	memcpy(&CP[i], fileSize, sizeLength);
	i += sizeLength;
	CP[i++] = PARAM_FILE_NAME;
	CP[i++] = nameLength;
	memcpy(&CP[i], fileName, nameLength);
	i += nameLength;

	if (llwrite(fd, CP, i) < 0)  {
		puts("[ERROR] CONTROL package not sent: serial port write failed...");
		rv = -1;
	}

	free(CP);

	if (rv) {	
		return -1;
	}

	if (C == CTRL_PKG_START) {
		puts("[INFORMATION] START control package successfully sent!");
	}
	else if (C == CTRL_PKG_END) {
		puts("[INFORMATION] END control package successfully sent!");
	}

	printf("[INFORMATION] fileSize=%s, fileName=%s\n", fileSize, fileName);

	return 0;
}

unsigned char testControl[] = {
	0x1, 0x0, 0x3,
	0x31, 0x33, 0x32,
	0x1, 0xd,
	0x6d, 0x79, 0x45, 0x78,
	0x61, 0x6d, 0x70, 0x6c,
	0x65, 0x2e, 0x74, 0x78, 0x74
};

static int receive_control(int fd, unsigned char* C, int* length, char* filename) {

	unsigned char* CP = (unsigned char*) malloc(MAX_SIZE * sizeof(unsigned char));
	unsigned packageSize = llread(fd, CP);
	int i = 3;

	if (packageSize < 0) {
		free(CP);
		puts("[ERROR] CONTROL package reception failed...");
		return -1;
	}

	if (CP[CTRL_C] == CTRL_PKG_START) {
		LOG("[INFORMATION] received START control package from TRANSMITTER...");
	}
	else if (CP[CTRL_C] == CTRL_PKG_END) {
		LOG("[INFORMATION] received END control package from TRANSMITTER...");
	}
	else {
		free(CP);
		puts("[ERROR] received wrong package: not a valid CONTROL package...");
		return -1;
	}

	*C = CP[CTRL_C];

	if (CP[CTRL_T1] != PARAM_FILE_SIZE) {
		free(CP);
		puts("[ERROR] received wrong parameter: PARAM_FILE_SIZE expected...");
		return -1;
	}

	unsigned fileSizeLength = CP[CTRL_L1];
	char* fileSize = (char*) malloc(fileSizeLength * sizeof(char));

	memcpy(fileSize, &CP[i], fileSizeLength);
	fileSize[fileSizeLength] = '\0';
	*length = atoi(fileSize);
	free(fileSize);
	i += fileSizeLength;

	if (CP[i++] != PARAM_FILE_NAME) {
		free(CP);
		puts("[ERROR] received wrong parameter: PARAM_FILE_NAME expected...");
		return -1;
	}

	const unsigned fileNameLength = CP[i++];
	const unsigned expectedSize = 5 + fileSizeLength + fileNameLength;

	memcpy(filename, &CP[i], fileNameLength);
	filename[fileNameLength] = '\0';
	free(CP);
	i += fileNameLength;

	if (i != expectedSize) {
		puts("[ERROR] received wrong package: size mismatch...");
		return -1;
	}

	printf("[INFORMATION] fileSize=%d, fileName=%s\n", *length, filename);

	return 0;
}

/*
 * APPLICATION LAYER FUNCTIONS
 */

static int application_SEND(void) {

	FILE* fp = fopen(al->filename, "rb");
	
	if (fp == NULL) {
		perror(al->filename);
		return -1;
	}

	printf("[INFORMATION] opened file %s for sending...\n", al->filename);

	int fileSize = calculate_size(fp);
	char fileSizeString[16];

	sprintf(fileSizeString, "%d", fileSize);

	// SEND "START" CONTROL PACKAGE
	if (send_control(al->fd, CTRL_PKG_START, fileSizeString, al->filename) < 0) {
		return -1;
	}

	printf("[INFORMATION] starting file transfer...\n");

	int sequenceNumber = 0;
	unsigned char* fileBuffer = (unsigned char*) malloc(MAX_SIZE * sizeof(unsigned char));
	unsigned bytesRead = 0;
	unsigned bytesWritten = 0;

	while ((bytesRead = fread(fileBuffer, 1, 200, fp)) > 0) {

		if (send_data(al->fd, (sequenceNumber++) % 255, fileBuffer, bytesRead) == -1) {
			return -1;
		}

		bzero(fileBuffer, MAX_SIZE);
		bytesWritten += bytesRead;
		logProgress(bytesWritten, fileSize);
	}

	// FREE ALLOCATED MEMORY
	free(fileBuffer);

	// CLOSE FILE
	if (fclose(fp) < 0) {
		perror(al->filename);
		return -1;
	}

	// SEND "END" CONTROL PACKAGE
	if (send_control(al->fd, CTRL_PKG_END, fileSizeString, al->filename) < 0) {
		return -1;
	}

	puts("[INFORMATION] file transfer completed successfully!");
	printf("[INFORMATION] TOTAL BYTES WRITTEN: %d bytes\n", bytesWritten);

	return 0;
}

static int application_RECEIVE(void) {
	
	unsigned char controlMessage;
	char* fileName = (char*) malloc(MAX_SIZE * sizeof(char));
	int sequenceNumber = -1;
	int fileSize;

	LOG("[INFORMATION] waiting for START control package from transmitter...");
	
	// RECEIVE "START" CONTROL PACKAGE
	if (receive_control(al->fd, &controlMessage, &fileSize, fileName) == -1) {
		return -1;
	}

	// CHECK IF VALID "START" CONTROL PACKAGE
	if (controlMessage != CTRL_PKG_START) {
		puts("[ERROR] received wrong control package: control field is not CTRL_PKG_START...");
		return -1;
	}

	// OPEN INPUT FILE FOR READING
	FILE* fp = fopen(al->filename, "wb");
	
	if (fp == NULL) {
		perror(al->filename);
		return -1;
	}

	printf("\n[INFORMATION] created output file: %s\n", al->filename);
	printf("[INFORMATION] expected output file size: %d (bytes)\n\n", fileSize);
	puts("[INFORMATION] starting file transfer...");

	unsigned bytesRead = 0;
	unsigned char* fileBuffer = (unsigned char*) malloc(MAX_SIZE * sizeof(unsigned char));
	
	while (bytesRead != fileSize) {
		
		int lastNumber = sequenceNumber;
		int length = 0;

		if (receive_data(al->fd, &sequenceNumber, fileBuffer, &length) == -1) {
			free(fileBuffer);
			return -1;
		}

		if (sequenceNumber && (lastNumber + 1 != sequenceNumber)) {
			printf("[ERROR] received sequence number %d, expected %d...\n", sequenceNumber, lastNumber + 1);
			free(fileBuffer);
			return -1;
		}

		fwrite(fileBuffer, 1, length, fp);
		bytesRead += length;
		logProgress(bytesRead, fileSize);
	}

	LOG("[READ] waiting for END control package from transmitter...");
	
	// CLOSE INPUT FILE
	if (fclose(fp) < 0) {
		perror(al->filename);
		return -1;
	}

	char* lastName = (char*) malloc(MAX_SIZE * sizeof(char));
	int lastSize;

	// RECEIVE "END" CONTROL PACKAGE
	if (receive_control(al->fd, &controlMessage, &lastSize, lastName) == -1) {
		return -1;
	}

	// CHECK FOR VALID "END" CONTROL PACKAGE
	if (controlMessage != CTRL_PKG_END) {
		puts("[ERROR] received wrong END package: control field is not CTRL_PKG_END...");
		return -1;
	}	
	
	// CHECK 
	if (strcmp(fileName, lastName) != 0) {
		puts("[ERROR] START and END control file name parameters don't match!");
		return -1;
	}

	// CHECK 
	if (fileSize != lastSize) {
		puts("[ERROR] START and END control file size parameters don't match!");
		return -1;
	}

	puts("[INFORMATION] file transfer completed successfully!");
	printf("[INFORMATION] TOTAL BYTES READ: %d bytes\n", bytesRead);
		
	return 0;
}

int application_start(void) {
	
	if (al == NULL || al->fd < 0) {
		return -1;
	}
	
	int rv = 0;
	
	if (al->mode == MODE_TRANSMITTER) {
		rv = application_SEND();
	}
	else if(al->mode == MODE_RECEIVER) {
		rv = application_RECEIVE();
	}
	
	return rv;
}

int application_close(void) {

	int rv = 0;

	if (llclose(al->fd, al->mode) == -1) {
		printf("[ERROR] llclose failed, connection wasn't terminated.");
		rv = -1;
	}
	
	free(al->filename);
	logStatistics();

	return rv;
}

int application_config(int baudrate, int retries, int timeout, int maxsize) {

	LinkLayer* ll = llinit(al->port, al->mode, baudrate, retries, timeout, maxsize);
	
	if (ll == NULL) {
		return -1;
	}
	
	al->fd = llopen(al->port, al->mode);

	if (al->fd < 0) {
		return -1;
	}
	
	al->maxsize = maxsize;
	logConnection();
	
	return 0;
}

int application_init(char* port, int mode, char* filename) {

	al = (ApplicationLayer*) malloc(sizeof(ApplicationLayer));
	
	if (al == NULL) {
		return -1;
	}

	al->mode = mode;
	al->filename = (char*) malloc(MAX_SIZE * sizeof(char));
	strcpy(al->filename, filename);
	strcpy(al->port, port);
	
	return 0;
}
